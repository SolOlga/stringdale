# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/docs/examples/009_mcp_agent.ipynb.

# %% auto 0
__all__ = ['format_chat_messages', 'has_tool_calls', 'format_tool_output', 'MCP_Chat_factory', 'execute_mcp_tool',
           'has_tool_result']

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 4
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, ConfigDict
from .. import Define, V, E, Condition, Scope
from ..chat import Chat
import os

from fastmcp import Client
import asyncio


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 6
def format_chat_messages(llm_response):
    """Format chat messages into OpenAI message format"""
    return {"role": llm_response['role'], "content": llm_response['content']}


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 7
def has_tool_calls(llm_response):
    return bool(llm_response.get('tool_calls', []))

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 8
def format_tool_output(tool_result):
    """
    Format the tool output messages for OpenAI format.

    Args:
        tool_result (list): List of dictionaries from execute_mcp_tool, each containing:
            - tool_id (str): The ID of the tool call
            - tool_name (str): The name of the tool
            - tool_content_texts (list): The output content from the tool
            - tool_args (dict): The arguments passed to the tool

    Returns:
        list: List of formatted messages in OpenAI format
    """
    messages = []
    for result in tool_result:
        messages.append({
            "role": "tool",
            "tool_call_id": result.get("tool_id"),
            "name": result.get("tool_name"),
            "content": result.get("tool_content_texts")
        })
    return messages

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 9
def MCP_Chat_factory(mcp_tool_selector_chat,execute_mcp_tool):
    # Factory that returns the MCP Agent diagram definition
    with Define('MCP Agent', type='decision') as MCP_Chat:
        # Start: User query comes in
        # Select tool: Chat with MCP tools to decide which tool to use
        V('select_tool', mcp_tool_selector_chat,
          inputs=['Start(messages=.)'],
          outputs=[
              ('format_chat_messages'),
              ('start_parallel_tools(tools=content)', Condition(has_tool_calls, '(llm_response=content)'))
          ])
        V('format_chat_messages', format_chat_messages,
          outputs=['End(messages = .)'])
        # Execute the selected tool
        V('start_parallel_tools',
        )
        with Scope('flow'):
            V('execute_tool', execute_mcp_tool,
              inputs=['start_parallel_tools(tool = tools.tool_calls)'],
              outputs=['format_tool_output(tool_result=.)'],
              for_each=['tool']
            )
            # Format the final answer for the user
        V('format_tool_output',format_tool_output,
          outputs=['End(messages = .)'])
    return MCP_Chat

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 13
async def execute_mcp_tool(tool):
    """
    Extracts the tool name and arguments from the tool dict,
    executes the tool via mcp_client, and returns both:
        1. the OpenAI tool_result-style message, and 
        2. the raw tool_result itself.
    """
    tool_name = tool['name']
    tool_args = tool['input']
    tool_id = tool['id']
    async with mcp_client:
        tool_result = await mcp_client.call_tool(tool_name, tool_args)
    
    # Extract content from tool_result.content
    # MCP supports multiple content types: text, images, audio, resource references, etc.
    # For backwards compatibility, tool_content_texts contains only text strings
    content_texts = []
    content_items = []  # Full structured content with type information
    
    for item in tool_result.content:
        if hasattr(item, 'text'):
            # Text content - add to both for backwards compatibility
            content_texts.append(item.text)
            content_items.append({
                'type': 'text',
                'text': item.text
            })
        elif hasattr(item, 'data'):
            # Image or other binary data (ImageResource, etc.)
            content_items.append({
                'type': 'image' if hasattr(item, 'mimeType') and 'image' in getattr(item, 'mimeType', '') else 'binary',
                'data': item.data,
                'mimeType': getattr(item, 'mimeType', None),
                'url': getattr(item, 'url', None)
            })
        else:
            # Unknown content type - try to serialize what we can
            content_items.append({
                'type': 'unknown',
                'raw': str(item)
            })
    
    return {
        "tool_name": tool_name,
        "tool_args": tool_args,
        "tool_id": tool_id,
        "tool_content_texts": content_texts,  # Backwards compatible: list of text strings
        "tool_content_items": content_items,  # Full content with type information
    }


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 21
def has_tool_result(mcp_output: Dict[str, Any]) -> bool:
    """
    Check if the mcp_chat output contains at least one tool_result in messages.
    
    Args:
        mcp_output: Output from mcp_chat sub-diagram, should have a 'messages' key
        
    Returns:
        True if any message has content with type 'tool_result', False otherwise
    """    
    messages = mcp_output.get('messages', [])
    # Iterate through each message
    for message in messages:
        if not isinstance(message, dict):
            continue
            
        content = message.get('content', [])
        
        # Handle content as a list
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict) and item.get('type') == 'tool_result':
                    return True
        
        # Handle content as a string (no tool_result)
        elif isinstance(content, str):
            continue
    
    return False
