# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/docs/examples/009_mcp_agent.ipynb.

# %% auto 0
__all__ = ['MCP_Chat_factory', 'execute_mcp_tool', 'has_tool_result']

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 10
def MCP_Chat_factory(mcp_tool_selector_chat,execute_mcp_tool):
    # Factory that returns the MCP Agent diagram definition
    with Define('MCP Agent', type='decision') as MCP_Chat:
        # Start: User query comes in
        # Select tool: Chat with MCP tools to decide which tool to use
        V('select_tool', mcp_tool_selector_chat,
          inputs=['Start(messages=.)'],
          outputs=[
              ('format_chat_messages'),
              ('start_parallel_tools(tools=content)', Condition(has_tool_calls, '(llm_response=content)'))
          ])
        V('format_chat_messages', format_chat_messages,
          outputs=['End(messages = .)'])
        # Execute the selected tool
        V('start_parallel_tools',
        )
        with Scope('flow'):
            V('execute_tool', execute_mcp_tool,
              inputs=['start_parallel_tools(tool = tools.tool_calls)'],
              outputs=['format_tool_output(tool_result=.)'],
              for_each=['tool']
            )
            # Format the final answer for the user
        V('format_tool_output',format_tool_output,
          outputs=['End(messages = .)'])
    return MCP_Chat

# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 14
async def execute_mcp_tool(tool):
    """
    Extracts the tool name and arguments from the tool dict,
    executes the tool via mcp_client, and returns both:
        1. the OpenAI tool_result-style message, and 
        2. the raw tool_result itself.
    """
    tool_name = tool['name']
    tool_args = tool['input']
    tool_id = tool['id']
    async with mcp_client:
        tool_result = await mcp_client.call_tool(tool_name, tool_args)
    
    # Extract content from tool_result.content
    # MCP supports multiple content types: text, images, audio, resource references, etc.
    # For backwards compatibility, tool_content_texts contains only text strings
    content_texts = []
    content_items = []  # Full structured content with type information
    
    for item in tool_result.content:
        if hasattr(item, 'text'):
            # Text content - add to both for backwards compatibility
            content_texts.append(item.text)
            content_items.append({
                'type': 'text',
                'text': item.text
            })
        elif hasattr(item, 'data'):
            # Image or other binary data (ImageResource, etc.)
            content_items.append({
                'type': 'image' if hasattr(item, 'mimeType') and 'image' in getattr(item, 'mimeType', '') else 'binary',
                'data': item.data,
                'mimeType': getattr(item, 'mimeType', None),
                'url': getattr(item, 'url', None)
            })
        else:
            # Unknown content type - try to serialize what we can
            content_items.append({
                'type': 'unknown',
                'raw': str(item)
            })
    
    return {
        "tool_name": tool_name,
        "tool_args": tool_args,
        "tool_id": tool_id,
        "tool_content_texts": content_texts,  # Backwards compatible: list of text strings
        "tool_content_items": content_items,  # Full content with type information
    }


# %% ../../nbs/docs/examples/009_mcp_agent.ipynb 23
def has_tool_result(mcp_output: Dict[str, Any]) -> bool:
    """
    Check if the mcp_chat output contains at least one tool_result in messages.
    
    Args:
        mcp_output: Output from mcp_chat sub-diagram, should have a 'messages' key
        
    Returns:
        True if any message has content with type 'tool_result', False otherwise
    """    
    messages = mcp_output.get('messages', [])
    # Iterate through each message
    for message in messages:
        if not isinstance(message, dict):
            continue
            
        content = message.get('content', [])
        
        # Handle content as a list
        if isinstance(content, list):
            for item in content:
                if isinstance(item, dict) and item.get('type') == 'tool_result':
                    return True
        
        # Handle content as a string (no tool_result)
        elif isinstance(content, str):
            continue
    
    return False
